import { NextRequest, NextResponse } from "next/server";
import * as crypto from "crypto";
import {
  StrKey,
  Keypair,
  TransactionBuilder,
  Networks,
  Operation,
  xdr,
  rpc,
  Contract,
  Address,
} from "@stellar/stellar-sdk";

// Load configuration from environment variables
const TESTNET_CONFIG = {
  rpcUrl: process.env.NEXT_PUBLIC_RPC_URL || "https://soroban-testnet.stellar.org",
  networkPassphrase: process.env.NEXT_PUBLIC_NETWORK_PASSPHRASE || Networks.TESTNET,
  verifierAddress: process.env.NEXT_PUBLIC_VERIFIER_ADDRESS!,
  counterAddress: process.env.NEXT_PUBLIC_COUNTER_ADDRESS!,
  smartAccountWasmHash: process.env.NEXT_PUBLIC_SMART_ACCOUNT_WASM_HASH!,
  bundlerSecret: process.env.BUNDLER_SECRET!,
};

// Validate required environment variables
if (!TESTNET_CONFIG.bundlerSecret) {
  throw new Error("BUNDLER_SECRET environment variable is required");
}
if (!TESTNET_CONFIG.verifierAddress || !TESTNET_CONFIG.counterAddress || !TESTNET_CONFIG.smartAccountWasmHash) {
  throw new Error("Missing required contract addresses in environment variables");
}

// Simple in-memory cache to track deployed accounts
// In production, use a database
const deployedAccounts: Map<string, { smartAccountAddress: string; gAddress: string }> = new Map();

// Derive Stellar G-address from Ed25519 public key bytes
function deriveGAddressFromPubkey(pubkeyHex: string): string {
  try {
    const pubkeyBytes = Buffer.from(pubkeyHex, "hex");
    // Use StrKey to encode raw Ed25519 public key bytes into G-address format
    const gAddress = StrKey.encodeEd25519PublicKey(pubkeyBytes);
    return gAddress;
  } catch (err) {
    console.error("Error deriving G-address:", err);
    throw new Error(`Failed to derive G-address from pubkey: ${err instanceof Error ? err.message : String(err)}`);
  }
}

// Fund account via Friendbot (testnet only)
async function fundAccountIfNeeded(gAddress: string): Promise<void> {
  try {
    // Check if account exists using Horizon API (simpler than Soroban RPC for this)
    const horizonResponse = await fetch(
      `https://horizon-testnet.stellar.org/accounts/${gAddress}`
    );
    if (horizonResponse.ok) {
      console.log(`Account ${gAddress} already funded`);
      return;
    }
  } catch (err) {
    console.log(`Account check failed, will try to fund:`, err);
  }

  // Account doesn't exist, fund via Friendbot
  console.log(`Funding account ${gAddress} via Friendbot...`);
  const response = await fetch(
    `https://friendbot.stellar.org?addr=${encodeURIComponent(gAddress)}`
  );
  if (!response.ok) {
    const errorText = await response.text();
    console.error(`Friendbot error:`, errorText);
    throw new Error(`Failed to fund account: ${response.statusText}`);
  }
  console.log(`Account ${gAddress} funded successfully`);
}

export async function POST(request: NextRequest) {
  try {
    const { publicKeyHex } = await request.json();

    if (!publicKeyHex || typeof publicKeyHex !== "string" || publicKeyHex.length !== 64) {
      return NextResponse.json(
        { error: "Invalid public key. Expected 64-character hex string." },
        { status: 400 }
      );
    }

    // Derive the user's Stellar G-address from their Phantom pubkey
    const userGAddress = deriveGAddressFromPubkey(publicKeyHex);
    console.log(`Derived G-address: ${userGAddress}`);

    // Check if already deployed for this pubkey
    if (deployedAccounts.has(publicKeyHex)) {
      const cached = deployedAccounts.get(publicKeyHex)!;
      return NextResponse.json({
        smartAccountAddress: cached.smartAccountAddress,
        gAddress: cached.gAddress,
        alreadyDeployed: true,
      });
    }

    // Fund the user's G-address via Friendbot (testnet)
    await fundAccountIfNeeded(userGAddress);

    // Generate deterministic salt from pubkey + version
    const SMART_ACCOUNT_VERSION = "v6";
    const saltHex = crypto.createHash("sha256").update(publicKeyHex + SMART_ACCOUNT_VERSION).digest("hex");
    const salt = Buffer.from(saltHex, "hex");

    console.log(`Deploying smart account for pubkey: ${publicKeyHex}`);
    console.log(`Using salt: ${saltHex}`);

    // Initialize Stellar SDK
    const server = new rpc.Server(TESTNET_CONFIG.rpcUrl);
    const bundlerKeypair = Keypair.fromSecret(TESTNET_CONFIG.bundlerSecret);

    let smartAccountAddress: string;

    try {
      // Get bundler account
      const bundlerAccount = await server.getAccount(bundlerKeypair.publicKey());

      // Build deployment transaction
      const deployTx = new TransactionBuilder(bundlerAccount, {
        fee: "1000000",
        networkPassphrase: TESTNET_CONFIG.networkPassphrase,
      })
        .addOperation(
          Operation.createCustomContract({
            address: new Address(bundlerKeypair.publicKey()),
            wasmHash: Buffer.from(TESTNET_CONFIG.smartAccountWasmHash, "hex"),
            salt: salt,
          })
        )
        .setTimeout(300)
        .build();

      // Simulate to get footprint and resource fees
      const simResult = await server.simulateTransaction(deployTx);

      if (rpc.Api.isSimulationError(simResult)) {
        throw new Error(`Deployment simulation failed: ${simResult.error}`);
      }

      // Assemble transaction with correct footprint
      const assembledTx = rpc.assembleTransaction(deployTx, simResult).build();
      assembledTx.sign(bundlerKeypair);

      // Submit deployment transaction
      const deployResult = await server.sendTransaction(assembledTx);

      if (deployResult.status === "ERROR") {
        throw new Error(`Deployment failed: ${deployResult.errorResult?.toXDR("base64")}`);
      }

      // Wait for transaction confirmation
      let deployTxResult: rpc.Api.GetTransactionResponse | undefined;
      for (let i = 0; i < 30; i++) {
        await new Promise((r) => setTimeout(r, 1000));
        deployTxResult = await server.getTransaction(deployResult.hash);
        if (deployTxResult.status !== rpc.Api.GetTransactionStatus.NOT_FOUND) {
          break;
        }
      }

      if (!deployTxResult) {
        throw new Error("Transaction not found after polling");
      }

      if (deployTxResult.status === rpc.Api.GetTransactionStatus.SUCCESS) {
        // Extract contract address from transaction result
        const result = deployTxResult as rpc.Api.GetSuccessfulTransactionResponse;
        const returnValue = result.returnValue;
        if (returnValue) {
          smartAccountAddress = Address.fromScAddress(returnValue as any).toString();
          console.log(`Deployed smart account: ${smartAccountAddress}`);
        } else {
          throw new Error("No return value from deployment transaction");
        }
      } else if (deployTxResult.status === rpc.Api.GetTransactionStatus.FAILED) {
        // Contract might already exist - compute the expected address
        const contractIdPreimage = xdr.ContractIdPreimage.contractIdPreimageFromAddress(
          new xdr.ContractIdPreimageFromAddress({
            address: Address.fromString(bundlerKeypair.publicKey()).toScAddress(),
            salt: salt,
          })
        );
        const networkIdHash = crypto.createHash("sha256").update(TESTNET_CONFIG.networkPassphrase, "utf8").digest();
        const hashIdPreimage = xdr.HashIdPreimage.envelopeTypeContractId(
          new xdr.HashIdPreimageContractId({
            networkId: networkIdHash,
            contractIdPreimage: contractIdPreimage,
          })
        );
        const contractIdHash = crypto.createHash("sha256").update(hashIdPreimage.toXDR()).digest();
        smartAccountAddress = StrKey.encodeContract(contractIdHash);
        console.log(`Smart account already exists: ${smartAccountAddress}`);
      } else {
        throw new Error(`Deployment transaction status: ${deployTxResult.status}`);
      }
    } catch (deployError: unknown) {
      const errorMessage = deployError instanceof Error ? deployError.message : String(deployError);
      // If contract already exists, compute the deterministic address
      if (errorMessage.includes("already exists") || errorMessage.includes("ExistingValue")) {
        const contractIdPreimage = xdr.ContractIdPreimage.contractIdPreimageFromAddress(
          new xdr.ContractIdPreimageFromAddress({
            address: Address.fromString(bundlerKeypair.publicKey()).toScAddress(),
            salt: salt,
          })
        );
        const networkIdHash = crypto.createHash("sha256").update(TESTNET_CONFIG.networkPassphrase, "utf8").digest();
        const hashIdPreimage = xdr.HashIdPreimage.envelopeTypeContractId(
          new xdr.HashIdPreimageContractId({
            networkId: networkIdHash,
            contractIdPreimage: contractIdPreimage,
          })
        );
        const contractIdHash = crypto.createHash("sha256").update(hashIdPreimage.toXDR()).digest();
        smartAccountAddress = StrKey.encodeContract(contractIdHash);
        console.log(`Smart account already exists (computed address): ${smartAccountAddress}`);
      } else {
        throw deployError;
      }
    }

    // Initialize the smart account with the Phantom pubkey using SDK
    try {
      const contract = new Contract(smartAccountAddress);
      const bundlerAccount = await server.getAccount(bundlerKeypair.publicKey());

      const initTx = new TransactionBuilder(bundlerAccount, {
        fee: "1000000",
        networkPassphrase: TESTNET_CONFIG.networkPassphrase,
      })
        .addOperation(
          contract.call(
            "initialize",
            new Address(TESTNET_CONFIG.verifierAddress).toScVal(),
            xdr.ScVal.scvBytes(Buffer.from(publicKeyHex, "hex")),
            new Address(TESTNET_CONFIG.counterAddress).toScVal()
          )
        )
        .setTimeout(300)
        .build();

      initTx.sign(bundlerKeypair);

      const initResult = await server.sendTransaction(initTx);

      if (initResult.status !== "ERROR") {
        // Wait for confirmation
        for (let i = 0; i < 30; i++) {
          await new Promise((r) => setTimeout(r, 1000));
          const txResult = await server.getTransaction(initResult.hash);
          if (txResult.status !== rpc.Api.GetTransactionStatus.NOT_FOUND) {
            if (txResult.status === rpc.Api.GetTransactionStatus.SUCCESS) {
              console.log(`Initialized smart account with pubkey`);
            }
            break;
          }
        }
      }
    } catch (initError: unknown) {
      const errorMessage = initError instanceof Error ? initError.message : String(initError);
      // Error #3001 = DuplicateContextRule (already initialized)
      // Error #3000 = ContextRuleNotFound (shouldn't happen but harmless)
      if (errorMessage.includes("#3001") || errorMessage.includes("already") || errorMessage.includes("ExistingValue")) {
        console.log(`Smart account already initialized (context rule exists)`);
      } else {
        console.error("Init error:", errorMessage.substring(0, 200));
        // Continue anyway - might already be initialized
      }
    }

    // Cache the deployment
    deployedAccounts.set(publicKeyHex, { smartAccountAddress, gAddress: userGAddress });

    return NextResponse.json({
      smartAccountAddress,
      gAddress: userGAddress,
      verifierAddress: TESTNET_CONFIG.verifierAddress,
      counterAddress: TESTNET_CONFIG.counterAddress,
      alreadyDeployed: false,
    });
  } catch (error) {
    console.error("Error deploying smart account:", error);
    // Return more detailed error info for debugging
    const errorMessage = error instanceof Error ? error.message : "Failed to deploy smart account";
    const errorStack = error instanceof Error ? error.stack : undefined;
    return NextResponse.json(
      {
        error: errorMessage,
        details: errorStack,
        type: error?.constructor?.name
      },
      { status: 500 }
    );
  }
}

export async function GET() {
  return NextResponse.json({
    verifierAddress: TESTNET_CONFIG.verifierAddress,
    counterAddress: TESTNET_CONFIG.counterAddress,
    network: "testnet",
  });
}
